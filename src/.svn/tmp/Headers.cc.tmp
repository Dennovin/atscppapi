/*
 * Headers.cc
 *
 *  Created on: Mar 13, 2013
 *      Author: mnilange
 */
#include "atscppapi/Headers.h"
#include "InitializableValue.h"
#include "logging_internal.h"
#include <ts/ts.h>
#include "atscppapi/noncopyable.h"

using atscppapi::Headers;
using std::string;
using std::list;
using std::pair;
using std::make_pair;
using std::ostringstream;

namespace atscppapi {

namespace {
  const int APPEND_INDEX = -1;
  const list<string> EMPTY_VALUE_LIST;
  const int FIRST_INDEX = 0;
}

/**
 * \private
 */
struct HeadersState: noncopyable {
  TSMBuffer hdr_buf_;
  TSMLoc hdr_loc_;
  InitializableValue<Headers::NameValuesMap> name_values_map_;
  bool detached_;
  HeadersState() : hdr_buf_(NULL), hdr_loc_(NULL), detached_(false) { }
};

}

Headers::Headers() {
  state_ = new HeadersState();
}

void Headers::init(void *hdr_buf, void *hdr_loc) {
  if (state_->hdr_buf_ || state_->hdr_loc_ || state_->detached_) {
    LOG_ERROR("Cannot reinitialize; hdr_buf %p, hdr_loc %p, detached %s", state_->hdr_buf_, state_->hdr_loc_,
              (state_->detached_ ? "true" : "false"));
    return;
  }
  state_->hdr_buf_ = static_cast<TSMBuffer>(hdr_buf);
  state_->hdr_loc_ = static_cast<TSMLoc>(hdr_loc);
}

void Headers::initDetached() {
  if (state_->hdr_buf_ || state_->hdr_loc_ || state_->detached_) {
    LOG_ERROR("Cannot reinitialize; hdr_buf %p, hdr_loc %p, detached %s", state_->hdr_buf_, state_->hdr_loc_,
              (state_->detached_ ? "true" : "false"));
    return;
  }
  state_->detached_ = true;
  state_->name_values_map_.setInitialized();
}

bool Headers::checkAndInitHeaders() const {
  if (state_->name_values_map_.isInitialized()) {
    return true;
  } else if ((state_->hdr_buf_ == NULL) || (state_->hdr_loc_ == NULL)) {
    LOG_ERROR("Failed to initialize! TS header handles not set; hdr_buf %p, hdr_loc %p", state_->hdr_buf_, 
              state_->hdr_loc_);
    return false;
  }
  state_->name_values_map_.getValueRef().clear();
  string key;
  const char *name, *value;
  int name_len, num_values, value_len;
  std::pair<NameValuesMap::iterator, bool> insert_result;
  TSMLoc field_loc = TSMimeHdrFieldGet(state_->hdr_buf_, state_->hdr_loc_, FIRST_INDEX);
  while (field_loc) {
    name = TSMimeHdrFieldNameGet(state_->hdr_buf_, state_->hdr_loc_, field_loc, &name_len);
    if (name && (name_len > 0)) {
      key.assign(name, name_len);
      // TODO do we trust ATS tokenizing? Dzmitry ran into a bug...
      int num_values = TSMimeHdrFieldValuesCount(state_->hdr_buf_, state_->hdr_loc_, field_loc);
      for (int i = 0; i < num_values; ++i) {
        value = TSMimeHdrFieldValueStringGet(state_->hdr_buf_, state_->hdr_loc_, field_loc, i, &value_len);
        if (value && value_len) {
          insert_result = state_->name_values_map_.getValueRef().insert(
            NameValuesMap::value_type(key, EMPTY_VALUE_LIST));
          NameValuesMap::iterator &inserted_element = insert_result.first;
          list<string> &value_list = inserted_element->second;
          value_list.push_back(string(value, value_len));
          LOG_DEBUG("Added value [%.*s] to header [%s]", value_len, value, key.c_str());
        } else {
          LOG_ERROR("Failed to get value at index %d of header [%s]", i, key.c_str());
        }
      }
    } else {
      LOG_ERROR("Failed to get name of header; hdr_buf %p, hdr_loc %p", state_->hdr_buf_, state_->hdr_loc_);
    }
    TSMLoc next_field_loc = TSMimeHdrFieldNext(state_->hdr_buf_, state_->hdr_loc_, field_loc);
    TSHandleMLocRelease(state_->hdr_buf_, state_->hdr_loc_, field_loc);
    field_loc = next_field_loc;
  }
  state_->name_values_map_.setInitialized();
  LOG_DEBUG("Initialized headers map");
  return true;
}

Headers::~Headers() {
  delete state_;
}

Headers::size_type Headers::erase(const std::string &k) {
  if (!checkAndInitHeaders()) {
    return 0;
  }
  if (!state_->detached_) {
    TSMLoc field_loc = TSMimeHdrFieldFind(state_->hdr_buf_, state_->hdr_loc_, k.c_str(), k.length());
    if (field_loc) {
      TSMimeHdrFieldDestroy(state_->hdr_buf_, state_->hdr_loc_, field_loc);
      TSHandleMLocRelease(state_->hdr_buf_, state_->hdr_loc_, field_loc);
    }
  }
  LOG_DEBUG("Erasing header [%s]", k.c_str());
  return state_->name_values_map_.getValueRef().erase(k);
}

Headers::const_iterator Headers::set(const pair<string, list<string> > &pair) {
  erase(pair.first);
  return append(pair);
}


Headers::const_iterator Headers::set(const string &key, const list<string> &val) {
  return set(make_pair(key,val));
}

Headers::const_iterator Headers::set(const string &key, const string &val) {
  std::list<std::string> values;
  values.push_back(val);
  return set(make_pair(key,values));
}

Headers::const_iterator Headers::append(const pair<string, list<string> > &pair) {
  if (!checkAndInitHeaders()) {
    return state_->name_values_map_.getValueRef().end();
  }

  const string &header_name = pair.first; // handy references
  const list<string> &new_values = pair.second;

  std::pair<NameValuesMap::iterator, bool> insert_result;
  if (state_->detached_) {
    insert_result = state_->name_values_map_.getValueRef().insert(make_pair(header_name, EMPTY_VALUE_LIST));
    list<string> &value_list = insert_result.first->second; // existing or newly inserted
    for (list<string>::const_iterator iter = new_values.begin(), end = new_values.end(); iter != end; ++iter) {
      value_list.push_back(*iter);
      LOG_DEBUG("Appended value [%s] to header [%s]", iter->c_str(), header_name.c_str());
    }
  } else {
    TSMLoc field_loc =
      TSMimeHdrFieldFind(state_->hdr_buf_, state_->hdr_loc_, header_name.c_str(), header_name.length());
    
    if (!field_loc) {
      TSMimeHdrFieldCreate(state_->hdr_buf_, state_->hdr_loc_, &field_loc);
      TSMimeHdrFieldNameSet(state_->hdr_buf_, state_->hdr_loc_, field_loc, header_name.c_str(), header_name.length());
      TSMimeHdrFieldAppend(state_->hdr_buf_, state_->hdr_loc_, field_loc);
      LOG_DEBUG("Created new structure for header [%s]", header_name.c_str());
    }
    for(list<string>::const_iterator ii = new_values.begin(); ii != new_values.end(); ++ii) {
      TSMimeHdrFieldValueStringInsert(state_->hdr_buf_, state_->hdr_loc_, field_loc, APPEND_INDEX, (*ii).c_str(),
                                      (*ii).length());
    }

    insert_result = state_->name_values_map_.getValueRef().insert(make_pair(header_name, EMPTY_VALUE_LIST));
    list<string> &value_list = insert_result.first->second; // existing or newly inserted

    //
    // Now because TSMimeHdrFieldValueStringInsert will (possibly) parse each value for commas, that is,
    // if you insert a list of three elements "Foo", "Bar,Baz", "Blah", this would become
    // four elements in the marshal buffer and we need to update our own map to reflect that.
    //
    // Rather than inserting the list<strings> directly into our map, we will actually rebuild it using the
    // Traffic Server HDR Marshal Buffer so we're 100% consistent with the internal representation.
    //
    if (!insert_result.second) {
      value_list.clear();
    }
    int num_values = TSMimeHdrFieldValuesCount(state_->hdr_buf_, state_->hdr_loc_, field_loc);
    string header_values_string; // used for logging
    for (int i = 0; i < num_values; ++i) {
      int value_len = 0;
      const char *value = TSMimeHdrFieldValueStringGet(state_->hdr_buf_, state_->hdr_loc_, field_loc, i, &value_len);
      if (value && value_len) {
        value_list.push_back(string(value, value_len));
        if (!header_values_string.empty()) {
          header_values_string += ',';
        }
        header_values_string += value_list.back();
      } else {
        LOG_ERROR("Got NULL/zero-length value for header [%s]; Skipping value", header_name.c_str());
      }
    }
    TSHandleMLocRelease(state_->hdr_buf_, state_->hdr_loc_, field_loc);
    LOG_DEBUG("Header [%s] has value(s) [%s]", header_name.c_str(), header_values_string.c_str());
  }
  return insert_result.first;
}

string Headers::getJoinedValues(const string &key, char value_delimiter) {
  string ret;
  Headers::NameValuesMap::iterator key_iter = state_->name_values_map_.getValueRef().find(key);
  if (key_iter == state_->name_values_map_.getValueRef().end()) {
    LOG_DEBUG("Header [%s] not present", key.c_str());
    return ret;
  }
  return getJoinedValues(key_iter->second);
}

string Headers::getJoinedValues(const list<string> &values, char delimiter) {
  string ret;
  ret.reserve(128);
  for (list<string>::const_iterator vals_iter = values.begin(), vals_end = values.end(); vals_iter != vals_end;
       ++vals_iter) {
    if (!ret.empty()) {
      ret += delimiter;
    }
    ret.append(*vals_iter);
  }
  return ret;
}


Headers::const_iterator Headers::append(const string &key, const list<string> &val) {
  return append(make_pair(key,val));
}

Headers::const_iterator Headers::append(const string &key, const string &val) {
  std::list<std::string> values;
  values.push_back(val);
  return append(make_pair(key,values));
}

Headers::const_iterator Headers::begin() const {
  checkAndInitHeaders();
  return state_->name_values_map_.getValueRef().begin();
}

Headers::const_iterator Headers::end() const {
  return state_->name_values_map_.getValueRef().end();
}

Headers::const_reverse_iterator Headers::rbegin() const {
  checkAndInitHeaders();
  return state_->name_values_map_.getValueRef().rbegin();
}

Headers::const_reverse_iterator Headers::rend() const {
  return state_->name_values_map_.getValueRef().rend();
}

Headers::const_iterator Headers::find(const string &k) const {
  checkAndInitHeaders();
  return state_->name_values_map_.getValueRef().find(k);
}

Headers::size_type Headers::count(const string &key) const {
  checkAndInitHeaders();
  return state_->name_values_map_.getValueRef().count(key);
}

bool Headers::empty() const {
  checkAndInitHeaders();
  return state_->name_values_map_.getValueRef().empty();
}

Headers::size_type Headers::max_size() const {
  return state_->name_values_map_.getValueRef().max_size();
}

Headers::size_type Headers::size() const {
  checkAndInitHeaders();
  return state_->name_values_map_.getValueRef().size();
}
