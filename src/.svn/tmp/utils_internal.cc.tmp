/*
 * utils_internal.cc
 *
 *  Created on: Mar 6, 2013
 *      Author: bgeffon
 */
#include "utils_internal.h"
#include <cassert>
#include <ts/ts.h>
#include <pthread.h>
#include <cstdlib>
#include <cassert>
#include <cstddef>
#include "atscppapi/Plugin.h"
#include "atscppapi/GlobalPlugin.h"
#include "atscppapi/Transaction.h"
#include "atscppapi/TransactionPlugin.h"
#include "atscppapi/TransformationType.h"
#include "InitializableValue.h"
#include "utils.h"
#include "logging_internal.h"

using namespace atscppapi;

namespace {

// This is the highest txn arg that can be used, we choose this
// value to minimize the likelihood of it causing any problems.
const int MAX_TXN_ARG = 15;
const int TRANSACTION_STORAGE_INDEX = MAX_TXN_ARG;

Transaction &getTransaction(TSHttpTxn ats_txn_handle) {
  Transaction *transaction = static_cast<Transaction *>(TSHttpTxnArgGet(ats_txn_handle, TRANSACTION_STORAGE_INDEX));
  if (!transaction) {
    transaction = new Transaction(static_cast<void *>(ats_txn_handle));
    LOG_DEBUG("Created new transaction object at %p for ats pointer %p", transaction, ats_txn_handle);
    TSHttpTxnArgSet(ats_txn_handle, TRANSACTION_STORAGE_INDEX, transaction);
  }
  return *transaction;
}

int handleTransactionEvents(TSCont cont, TSEvent event, void *edata) {
  // This function is only here to clean up Transaction objects
  TSHttpTxn ats_txn_handle = static_cast<TSHttpTxn>(edata);
  Transaction &transaction = getTransaction(ats_txn_handle);
  LOG_DEBUG("Got event %d on continuation %p for transaction (ats pointer %p, object %p)", event, cont,
            ats_txn_handle, &transaction);
  TSMBuffer hdr_buf;
  TSMLoc hdr_loc;
  switch (event) {
  case TS_EVENT_HTTP_POST_REMAP:
    transaction.getClientRequest().getUrl().reset();
    break;
  case TS_EVENT_HTTP_SEND_REQUEST_HDR:
    transaction.initServerRequest();
    break;
  case TS_EVENT_HTTP_READ_RESPONSE_HDR:
    transaction.initServerResponse();
    break;
  case TS_EVENT_HTTP_SEND_RESPONSE_HDR:
    transaction.initClientResponse();
    break;
  case TS_EVENT_HTTP_TXN_CLOSE:
    { // opening scope to declare plugins variable below 
      const std::list<atscppapi::TransactionPlugin *> &plugins = transaction.getPlugins();
      for (std::list<atscppapi::TransactionPlugin *>::const_iterator iter = plugins.begin(), end = plugins.end();
           iter != end; ++iter) {
        LOG_DEBUG("Deleting transaction plugin at %p", *iter);
        delete *iter;
      }
      delete &transaction;
    }
    break;
  default:
    assert(false); /* we should never get here */
    break;
  }    
  TSHttpTxnReenable(ats_txn_handle, TS_EVENT_HTTP_CONTINUE);
  return 0;
}

void setupTransactionManagement() {
  // We must always have a cleanup handler available
  TSMutex mutex = NULL;
  TSCont cont = TSContCreate(handleTransactionEvents, mutex);
  TSHttpHookAdd(TS_HTTP_POST_REMAP_HOOK, cont);
  TSHttpHookAdd(TS_HTTP_SEND_REQUEST_HDR_HOOK, cont);
  TSHttpHookAdd(TS_HTTP_READ_RESPONSE_HDR_HOOK, cont);
  TSHttpHookAdd(TS_HTTP_SEND_RESPONSE_HDR_HOOK, cont);
  TSHttpHookAdd(TS_HTTP_TXN_CLOSE_HOOK, cont);
  atscppapi::transaction_data_caching_enabled = (getenv(utils::DISABLE_DATA_CACHING_ENV_FLAG.c_str()) == NULL);
  LOG_DEBUG("Initialized transaction management");
  // TODO is existence of env variable enough or should we expect a specific value?
}

void inline invokePluginForEvent(Plugin *plugin, TSHttpTxn ats_txn_handle, TSEvent event) {
  Transaction &transaction = getTransaction(ats_txn_handle);
  switch (event) {
  case TS_EVENT_HTTP_PRE_REMAP:
    plugin->handleReadRequestHeadersPreRemap(transaction);
    break;
  case TS_EVENT_HTTP_POST_REMAP:
    plugin->handleReadRequestHeadersPostRemap(transaction);
    break;
  case TS_EVENT_HTTP_SEND_REQUEST_HDR:
    plugin->handleSendRequestHeaders(transaction);
    break;
  case TS_EVENT_HTTP_READ_RESPONSE_HDR:
    plugin->handleReadResponseHeaders(transaction);
    break;
  case TS_EVENT_HTTP_SEND_RESPONSE_HDR:
    plugin->handleSendResponseHeaders(transaction);
    break;
  case TS_EVENT_HTTP_OS_DNS:
    plugin->handleOsDns(transaction);
    break;
  default:
    assert(false); /* we should never get here */
    break;
  }
}

} /* anonymous namespace */

TSHttpHookID utils::internal::convertInternalHookToTsHook(HookType hooktype) {
  switch (hooktype) {
  case HOOK_READ_REQUEST_HEADERS_POST_REMAP:
    return TS_HTTP_POST_REMAP_HOOK;
  case HOOK_READ_REQUEST_HEADERS_PRE_REMAP:
    return TS_HTTP_PRE_REMAP_HOOK;
  case HOOK_READ_RESPONSE_HEADERS:
    return TS_HTTP_READ_RESPONSE_HDR_HOOK;
  case HOOK_SEND_REQUEST_HEADERS:
    return TS_HTTP_SEND_REQUEST_HDR_HOOK;
  case HOOK_SEND_RESPONSE_HEADERS:
    return TS_HTTP_SEND_RESPONSE_HDR_HOOK;
  case HOOK_OS_DNS:
    return TS_HTTP_OS_DNS_HOOK;
  default:
    assert(false); // shouldn't happen, let's catch it early
    break;
  }
  return static_cast<TSHttpHookID>(-1);
}

TSHttpHookID utils::internal::convertInternalTransformationTypeToTsHook(TransformationType type) {
  TSHttpHookID hook_id;
  switch (type) {
    case RESPONSE_TRANSFORMATION:
      return TS_HTTP_RESPONSE_TRANSFORM_HOOK;
    case REQUEST_TRANSFORMATION:
      return TS_HTTP_REQUEST_TRANSFORM_HOOK;
    default:
      assert(false); // shouldn't happen, let's catch it early
      break;
  }
  return static_cast<TSHttpHookID>(-1);
}

<<<<<<< .mine
void utils::internal::invokePluginForEvent(TransactionPlugin *plugin, TSHttpTxn ats_txn_handle, TSEvent event) {
  ::invokePluginForEvent(static_cast<Plugin *>(plugin), ats_txn_handle, event);
=======
void utils::internal::invokePluginForEvent(Plugin *plugin, TSHttpTxn ats_txn_handle, TSEvent event) {
  Transaction &transaction = getTransaction(ats_txn_handle);
  LOG_DEBUG("Invoking plugin at %p for transaction (ats pointer %p, object %p) for event %d", plugin,
            ats_txn_handle, &transaction, event);
  switch (event) {
  case TS_EVENT_HTTP_PRE_REMAP:
    plugin->handleReadRequestHeadersPreRemap(transaction);
    break;
  case TS_EVENT_HTTP_POST_REMAP:
    plugin->handleReadRequestHeadersPostRemap(transaction);
    break;
  case TS_EVENT_HTTP_SEND_REQUEST_HDR:
    plugin->handleSendRequestHeaders(transaction);
    break;
  case TS_EVENT_HTTP_READ_RESPONSE_HDR:
    plugin->handleReadResponseHeaders(transaction);
    break;
  case TS_EVENT_HTTP_SEND_RESPONSE_HDR:
    plugin->handleSendResponseHeaders(transaction);
    break;
  case TS_EVENT_HTTP_OS_DNS:
    plugin->handleOsDns(transaction);
    break;
  default:
    assert(false); /* we should never get here */
    break;
  }
>>>>>>> .r659575
}

void utils::internal::invokePluginForEvent(GlobalPlugin *plugin, TSHttpTxn ats_txn_handle, TSEvent event) {
  ::invokePluginForEvent(static_cast<Plugin *>(plugin), ats_txn_handle, event);
}

std::string utils::internal::consumeFromTSIOBufferReader(TSIOBufferReader reader) {
  std::string str;
  int avail = TSIOBufferReaderAvail(reader);

  if (avail != TS_ERROR) {
    int consumed = 0;
    if (avail > 0) {
      str.reserve(avail + 1);

      int64_t data_len;
      const char *char_data;
      TSIOBufferBlock block = TSIOBufferReaderStart(reader);
      while (block != NULL) {
        char_data = TSIOBufferBlockReadStart(block, reader, &data_len);
        str.append(char_data, data_len);
        consumed += data_len;
        block = TSIOBufferBlockNext(block);
      }
    }
    TSIOBufferReaderConsume(reader, consumed);
  } else {
    LOG_ERROR("TSIOBufferReaderAvail returned error code %d for reader %p", avail, reader);
  }

  return str;
}


HttpVersion utils::internal::getHttpVersion(TSMBuffer hdr_buf, TSMLoc hdr_loc) {
  int version = TSHttpHdrVersionGet(hdr_buf, hdr_loc);
  if (version != TS_ERROR) {
    if ((TS_HTTP_MAJOR(version) == 0) && (TS_HTTP_MINOR(version) == 0)) {
      return HTTP_VERSION_0_9;
    }
    if ((TS_HTTP_MAJOR(version) == 1) && (TS_HTTP_MINOR(version) == 0)) {
      return HTTP_VERSION_1_0;
    }
    if ((TS_HTTP_MAJOR(version) == 1) && (TS_HTTP_MINOR(version) == 1)) {
      return HTTP_VERSION_1_1;
    } else {
      LOG_ERROR("Unrecognized version %d", version);
    }
  } else {
    LOG_ERROR("Could not get version; hdr_buf %p, hdr_loc %p", hdr_buf, hdr_loc);
  }
  return HTTP_VERSION_UNKNOWN;
}

void utils::internal::initTransactionManagement() {
  static pthread_once_t setup_pthread_once_control = PTHREAD_ONCE_INIT;
  pthread_once(&setup_pthread_once_control, setupTransactionManagement);
}
