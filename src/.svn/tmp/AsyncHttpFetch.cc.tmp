/*
 * AsyncHttpFetch.cc
 *
 *  Created on: Apr 9, 2013
 *      Author: bgeffon
 */

#include "atscppapi/AsyncHttpFetch.h"
#include <ts/ts.h>
#include <arpa/inet.h>
#include "logging_internal.h"

using namespace atscppapi;
using std::string;

/**
 * \private
 */
struct atscppapi::AsyncHttpFetchState: noncopyable {
  string request_;
  shared_ptr<AsyncDispatchControllerBase> dispatch_controller_;

  AsyncHttpFetchState(string request) : request_(request) {
  }

  ~AsyncHttpFetchState() {
  }
};

namespace {

const unsigned int LOCAL_IP_ADDRESS = 0x0100007f;
const int LOCAL_PORT = 8080;

enum FetchResult {
  SUCCESS = 10000,
  TIMEOUT,
  FAILURE
};

static int handleFetchEvents(TSCont cont, TSEvent event, void *edata) {
  LOG_DEBUG("Fetch result returned event = %d, edata = %p", event, edata);
  AsyncHttpFetch *fetch_provider = static_cast<AsyncHttpFetch *>(TSContDataGet(cont));

  /*
   * Parse the response
   */
  TSHttpTxn txn = static_cast<TSHttpTxn>(edata);
  int dataLen;
  const char *dataStart = TSFetchRespGet(txn, &dataLen);
  const char *dataEnd = dataStart + dataLen;
  string body;

  fetch_provider->full_result_ = string(dataStart,dataEnd);

  TSHttpParser parser = TSHttpParserCreate();
  TSMBuffer buf = TSMBufferCreate();
  TSMLoc hdrLoc = TSHttpHdrCreate(buf);
  TSHttpHdrTypeSet(buf, hdrLoc, TS_HTTP_TYPE_RESPONSE);
  if (TSHttpHdrParseResp(parser, buf, hdrLoc, &dataStart, dataEnd) == TS_PARSE_DONE)
  {
    TSHttpStatus status = TSHttpHdrStatusGet(buf, hdrLoc);
    size_t bodyLen = dataEnd - dataStart; // dataStart will now be pointing to body
    body.assign(dataStart, bodyLen);
    LOG_DEBUG("Fetch result had a status code of %d with a body length of %d", status, bodyLen);
  } else {
    /* log unable to parse error */
    event = static_cast<TSEvent>(FAILURE);
  }


  TSHandleMLocRelease(buf, 0, hdrLoc);
  TSMBufferDestroy(buf);
  TSHttpParserDestroy(parser);

  if (!fetch_provider->state_->dispatch_controller_->dispatch()) {
    LOG_DEBUG("Unable to dispatch result from AsyncFetch because promise has died.");
  }

  switch (event)
  {
    case SUCCESS: {
    }
    break;
    case FAILURE: {
    }
    break;
    case TIMEOUT: {
    }
    break;
    default:
    break;
  }

  delete fetch_provider; // we must always be sure to clean up the provider when we're done with it.
  TSContDestroy(cont);
  return 0;
}

}

AsyncHttpFetch::AsyncHttpFetch(string request) {
  LOG_DEBUG("Created new AsyncHttpFetch object", this);
  state_ = new AsyncHttpFetchState(request);
}

void AsyncHttpFetch::run(shared_ptr<AsyncDispatchControllerBase> sender) {
  state_->dispatch_controller_ = sender;

  TSCont fetchCont = TSContCreate(handleFetchEvents, TSMutexCreate());
  TSContDataSet(fetchCont, static_cast<void *>(this)); // Providers have to clean them selves up when they are done.

  TSFetchEvent eventIds;
  eventIds.success_event_id = SUCCESS;
  eventIds.failure_event_id = FAILURE;
  eventIds.timeout_event_id = TIMEOUT;

  struct sockaddr_in addr;
  addr.sin_family = AF_INET;
  addr.sin_addr.s_addr = LOCAL_IP_ADDRESS;
  addr.sin_port = LOCAL_PORT;
  LOG_DEBUG("Issing TSFetchUrl with a request of length %d", state_->request_.size());
  TSFetchUrl(state_->request_.c_str(), state_->request_.size(), reinterpret_cast<struct sockaddr const *>(&addr),
            fetchCont, AFTER_BODY, eventIds);

}

AsyncHttpFetch::~AsyncHttpFetch() {
  delete state_;
}
